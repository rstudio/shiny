% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test-server.R
\name{testServer}
\alias{testServer}
\title{Reactive testing for Shiny server functions and modules}
\usage{
testServer(app = NULL, expr, args = list(), session = MockShinySession$new())
}
\arguments{
\item{app}{A server function (i.e. a function with \code{input}, \code{output},
and \code{session}), or a module function (i.e. a function with first
argument \code{id} that calls \code{\link[=moduleServer]{moduleServer()}}.

You can also provide an app, a path an app, or anything that
\code{\link[=as.shiny.appobj]{as.shiny.appobj()}} can handle.}

\item{expr}{Test code containing expectations. The objects from inside the
server function environment will be made available in the environment of
the test expression (this is done using a data mask with
\code{\link[rlang:eval_tidy]{rlang::eval_tidy()}}). This includes the parameters of the server function
(e.g. \code{input}, \code{output}, and \code{session}), along with any other values
created inside of the server function.}

\item{args}{Additional arguments to pass to the module function. If \code{app} is
a module, and no \code{id} argument is provided, one will be generated and
supplied automatically.}

\item{session}{The \code{\link{MockShinySession}} object to use as the \link[=domains]{reactive domain}. The same session object is used as the domain both
during invocation of the server or module under test and during evaluation
of \code{expr}.}
}
\description{
A way to test the reactive interactions in Shiny applications. Reactive
interactions are defined in the server function of applications and in
modules.
}
\examples{
# Testing a server function  ----------------------------------------------
server <- function(input, output, session) {
  x <- reactive(input$a * input$b)
}

testServer(server, {
  session$setInputs(a = 2, b = 3)
  stopifnot(x() == 6)
})


# Testing a module --------------------------------------------------------
# Testing the server function doesn't require a UI, but we've included it
# here for completeness. In this simple app, a user clicks a button to
# multiply a value by the module's multiplier argument. In the tests below,
# we'll make sure the value is 1, 2, 4, etc. with each button click.
multModuleUI <- function(id) {
  ns <- NS(id)
  tagList(
    textOutput(ns("txt")),
    actionButton(ns("multiply_it"), "Multiply It")
  )
}

multModuleServer <- function(id, multiplier = 2) {
  moduleServer(id, function(input, output, session) {
    the_value <- reactive({
      max(input$multiply_it * multiplier, 1)
    })
    output$txt <- renderText({
      paste("The value is", the_value())
    })
  })
}

testServer(multModuleServer, args = list(multiplier = 2), {
  # Set the initial button value to 0
  session$setInputs(multiply_it = 0)
  stopifnot(the_value() == 1)
  stopifnot(output$txt == "The value is 1")

  # Simulate two button clicks
  session$setInputs(multiply_it = 2)
  stopifnot(the_value() == 4)
  stopifnot(output$txt == "The value is 4")

  # Note: you're also free to use third-party
  # testing packages like testthat:
  #   expect_equal(myreactive(), 1)
})
}
