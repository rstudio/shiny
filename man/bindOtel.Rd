% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bind-otel.R
\name{bindOtel}
\alias{bindOtel}
\title{Add Open Telemetry for reactivity to an object}
\usage{
bindOtel(x, ...)
}
\arguments{
\item{x}{The object to add caching to.}

\item{...}{Future parameter expansion.}
}
\description{
\code{bindOtel()} adds Open Telemetry for \code{\link[=reactive]{reactive()}} expressions and \verb{render*}
functions (like \code{\link[=renderText]{renderText()}}, \code{\link[=renderTable]{renderTable()}}, ...).

Wrapper to creating an active reactive Open Telemetry span that closes when
the reactive expression is done computing. Typically this is when the
reactive expression finishes (synchronous) or when the returned promise is
done computing (asynchronous).
}
\section{Async with Open Telemetry}{


With a reactive expression, the key and/or value expression can be
\emph{asynchronous}. In other words, they can be promises --- not regular R
promises, but rather objects provided by the
\href{https://rstudio.github.io/promises/}{\pkg{promises}}  package, which
are similar to promises in JavaScript. (See \code{\link[promises:promise]{promises::promise()}} for more
information.) You can also use \code{\link[mirai:mirai]{mirai::mirai()}} or \code{\link[future:future]{future::future()}}
objects to run code in a separate process or even on a remote machine.

When reactive expressions are being calculated in parallel (by having
another reactive promise compute in the main process), the currently active
Open Telemetry span will be dynamically swapped out according to the
currently active reactive expression. This means that as long as a promise
was \code{then()}ed or \code{catch()}ed with an active Open Telemetry span, the span
will be correctly propagated to the next step (and subsequently other
steps) in the promise chain.

While the common case is for a reactive expression to be created
synchronously, troubles arise when the reactive expression is created
asynchronously. The span \strong{must} be created before the reactive expression
is executed, it \strong{must} be active for the duration of the expression, and
it \strong{must} not be closed until the reactive expression is done executing.
This is not easily achieved with a single function call, so we provide a
way to create a reactive expression that is bound to an Open Telemetry
span.
}

\examples{
# TODO: Update examples!!
\dontrun{
rc <- bindCache(
  x = reactive({
    Sys.sleep(2)   # Pretend this is expensive
    input$x * 100
  }),
  input$x
)

# Can make it prettier with the \%>\% operator
library(magrittr)

rc <- reactive({
  Sys.sleep(2)
  input$x * 100
}) \%>\%
  bindCache(input$x)

}

## Only run app examples in interactive R sessions
if (interactive()) {

# Basic example
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      # The value expression is an _expensive_ computation
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)

    output$txt <- renderText(r())
  }
)


# Caching renderText
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    output$txt <- renderText({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)
  }
)


# Demo of using events and caching with an actionButton
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    actionButton("go", "Go"),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y) \%>\%
      bindEvent(input$go)
      # The cached, eventified reactive takes a reactive dependency on
      # input$go, but doesn't use it for the cache key. It uses input$x and
      # input$y for the cache key, but doesn't take a reactive dependency on
      # them, because the reactive dependency is superseded by addEvent().

    output$txt <- renderText(r())
  }
)

}

}
\seealso{
\code{\link[=bindCache]{bindCache()}} and \code{\link[=bindEvent]{bindEvent()}} for other ways to bind to your reactives.
}
