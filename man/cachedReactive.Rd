% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reactive-cached.R
\name{cachedReactive}
\alias{cachedReactive}
\title{Create a reactive expression with caching}
\usage{
cachedReactive(
  key,
  value,
  ...,
  event = NULL,
  ignoreNULL = TRUE,
  label = NULL,
  domain = getDefaultReactiveDomain(),
  cache = "app"
)
}
\arguments{
\item{key}{An expression or quosure that returns a value that will be hashed
and used as a cache key. This key should be a unique identifier for the
value: the assumption is that if the cache key is the same, then the value
of \code{expr} is the same. If two separate \code{cachedReactive}s have the same key,
the value is assumed to be the same. To avoid this, you can add an
arbitrary identifier (like an ID string) to the cache key.}

\item{value}{The expression or quosure that produces the return value of the
\code{cachedReactive}. It will be executed within an \code{\link[=isolate]{isolate()}} scope.}

\item{...}{Other arguments are ignored.}

\item{event}{An optional expression or quosure used for reactivity. If
non-NULL, then \code{event} will be evaluated in a reactive context, and \code{value}
will be evaluated in an isolated context (and it will not be used for
reactive dependencies).}

\item{ignoreNULL}{If \code{TRUE}, then if \code{event} evaluates to \code{NULL}, then a
silent exception will be raised and the cache key and the value will not be
computed. See \code{\link[=req]{req()}} for more on silent exceptions.}

\item{label}{A label for the reactive expression, useful for debugging.}

\item{domain}{See \link{domains}.}

\item{cache}{The scope of the cache, or a cache object. This can be \code{"app"}
(the default), \code{"session"}, or a cache object like a \code{\link[=diskCache]{diskCache()}}. See the
Cache Scoping section for more information.}
}
\description{
Ordinary \code{\link[=reactive]{reactive()}} expressions will cache their most recent value. This
can make computation more efficient, because time-consuming code can execute
once and the result can be used in multiple different places without needing
to re-execute the code.

With \code{cachedReactive()}, any number of previous values can be cached. The
most important difference in using \code{cachedReactive()} is that you must
provide \code{key}, which is an expression that generates as a \emph{cache key}, in
addition to \code{value}, which is an expression that generates the value returned
by the \code{cachedReactive()}.

For each possible value returned by \code{key}, there should be one possible value
returned by \code{value}; a given value of \code{key} should not correspond to multiple
possible values of \code{value}.

The way to use this is to have a \code{key} that is fast to compute, and a \code{value}
that is expensive to compute. It evaluates the \code{key}, and then serializes and
hashes the result. If the resulting hashed key is in the cache, then it
simply retrieves and returns it; if not, then it executes \code{value}, stores the
result in the cache, and returns it.

The \code{key} should be fast to compute, and ideally it will return an object
that is not too large, since the object must be serialized and hashed.
Typically, \code{key} will use any reactive inputs that are used by \code{value}, but
will do something that is fast and simple with them, like put them together
in a list. It is also best to use non-reference objects, since the
serialization of these objects may not capture relevant changes.

\code{cachedReactive()} also can take an \code{event} so that it behaves similar to
\code{\link[=eventReactive]{eventReactive()}}. See more in the \strong{Event expression} section.
}
\section{Cache keys and reactivity}{


Because the value from \code{value} is cached, it is not necessarily
re-executed, and therefore it can't be used to decide what objects to take
reactive dependencies on. Instead, the \code{key} is used to figure out which
objects to take reactive dependencies on. In short, the \code{key} is reactive,
and \code{value} is not (it is run inside of \code{\link[=isolate]{isolate()}}).

Here's an example of what not to do: if \code{key=input$x} and \code{value={input$x + input$y}}, then it will only take a reactive dependency on \code{input$x} -- it
won't recompute \code{value} when \code{input$y} changes. Moreover, the cache won't
use \code{input$y} as part of the key, and so it could return incorrect values
in the future when it retrieves values from the cache. (See the examples
below for an example of this.)

A better cache key would be something like \code{list(input$x, input$y)}. This
does two things: it ensures that a reactive dependency is taken on both \code{x}
and \code{y}, and it also makes sure that both values are represented in the
cache key.

In general, \code{key} should use the same reactive inputs as \code{value}, but the
computation should be simpler. If there are other (non-reactive) values
that are consumed, such as external data sources, they should be used in
the \code{key} as well. Note that if the \code{key} is large, it can make sense to do
some sort of reduction on it so that the serialization and hashing of the
cache key is not too expensive.

Remember that the \code{key} is \emph{reactive}, so it is not re-executed every
single time that someone accesses the \code{cachedReactive}. For example,
suppose we have this \code{cachedReactive}:\if{html}{\out{<div class="NA">}}\preformatted{r <- cachedReactive(
 key = list(input$x, input$y),
 value = \{ input$x + input$y \}
)
}\if{html}{\out{</div>}}

The first time someone calls \code{r()}, it executes both \code{key} and \code{value}. If
someone calls \code{r()} again, then it does not need to re-execute \code{key}, because
that \code{expr} has not been invalidated via a change to \code{input$x} or \code{input$y};
it simply returns the previous value. However, if \code{input$x} or \code{input$y}
changes, then the reactive expression will be invalidated, and the next time
that someone calls \code{r()}, \code{key} will need to be re-executed.
}

\section{Event expressions and reactivity}{


Typically, the \code{key} is reactive, and the \code{value} is not (it is run within
\code{\link[=isolate]{isolate()}}). However, there are times when this isn't ideal: perhaps you
have \link{sliderInput}s \code{x} and \code{y}, but you don't want the computation to
occur until the user sets both \code{x} and \code{y}, and then clicks on an
\link{actionButton} named \code{go}.

The value of \code{input$go} shouldn't be included in the cache key, because its
value is not relevant to the calculation involving \code{input$x} and \code{input$y}.
You also don't want to take a reactive dependency on \code{input$x} and
\code{input$y}, because then any changes to those values would cause this cached
reactive to do the computation or fetch the value from the cache and return
it.

In short, in this case, you want to take a reactive dependency on
\code{input$go} and not use its value for the cache key, and you want to \strong{not}
take a reactive dependency on \code{input$x} and \code{input$y} but use those values
for the cache key.

This can be done by using \code{event}, similar to in the \code{\link[=eventReactive]{eventReactive()}}
function. If a non-NULL \code{event} is provided to \code{cachedReactive()}, then it
will be used for the reactive dependencies but its value will be ignored,
and the \code{key} will be used for its value, but it will be executed in an
\code{\link[=isolate]{isolate()}}, so it will not be used for its reactive dependencies.

In the example described above, you would use something like:\if{html}{\out{<div class="NA">}}\preformatted{r <- cachedReactive(
 event = input$go,
 key = list(input$x, input$y),
 value = \{ input$x + input$y \}
)
}\if{html}{\out{</div>}}
}

\section{Async with cached reactives}{


With a cached reactive expression, they key and/or value expression can be
\emph{asynchronous}. In other words, they can be promises -- not regular R
promises, but rather objects provided by the promises package, which are
similar to promises in JavaScript. (See \code{\link[promises:promise]{promises::promise()}} for more
information.) You can also use \code{\link[future:future]{future::future()}} objects to run code in a
separate process or even on a remote machine.

If \code{value} is a promise, then anything that consumes the \code{cachedReactive}
must expect it to return a promise.

Similarly, if \code{key} or \code{event} is a promise (in other words, if they are
asynchronous), then the entire \code{cachedReactive} must be asynchronous, since
the key must be computed before \code{value} is evaluated (or the value is
retrieved from the cache). Anything that consumes the \code{cachedReactive} must
therefore expect it to return a promise.
}

\section{Cache key internals}{


The actual cache key that is used internally takes value from evaluating
\code{key} and combines it with the (unevaluated) \emph{body} of the \code{value}
expression.

This means that if there are two \code{cachedReactive}s which use the same value
from evaluating \code{key}, but different \code{value} expressions, then they will not
need to worry about collisions.

However, if two \code{cachedReactive}s have the identical \code{key} and \code{value}
expressions, they will share the cached values. This is useful when using
\code{cache="app"}: there may be multiple user sessions which create separate
\code{cachedReactive} objects (by executing the server function multiple times),
and those \code{cachedReactive} objects across sessions can share values in the
cache.
}

\examples{
## Only run examples in interactive R sessions
if (interactive()) {

# Basic example
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    "x * y: ",
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- cachedReactive(
      # Use input$x and input$y for the cache key. This is a reactive
      # expression.
      list(input$x, input$y),
      {
        # The value expression is an expensive computation
        message("Doing expensive computation...")
        Sys.sleep(2)
        input$x * input$y
      }
    )
    output$txt <- renderText(r())
  }
)


# Demo of using event with an actionButton
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    actionButton("go", "Go"),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- cachedReactive(
      # Take a reactive dependency on input$go, but don't use its value
      # for the cache key.
      event = input$go,
      # Use input$x and input$y for the cache key, but don't take a reactive
      # dependency on them.
      key = {
        list(input$x, input$y)
      },
      {
        message("Doing expensive computation...")
        Sys.sleep(2)
        input$x * input$y
      }
    )
    output$txt <- renderText(r())
  }
)

}

}
