{
  "version": 3,
  "sources": ["../../../srcts/extras/textarea-autoresize.ts"],
  "sourcesContent": ["// By importing the css file, it will be copied to the output directory.\nimport \"./textarea-autoresize.css\";\n\nexport interface DOMEvent<T extends EventTarget> extends Event {\n  readonly target: T;\n}\n\nfunction onDelegatedEvent(\n  eventName: string,\n  selector: string,\n  callback: (target: HTMLTextAreaElement) => void\n) {\n  document.addEventListener(eventName, (e) => {\n    const e2 = e as DOMEvent<HTMLTextAreaElement>;\n    if (e2.target.matches(selector)) {\n      callback(e2.target);\n    }\n  });\n}\n\n// Use a single intersectionObserver as they are slow to create / use.\nlet textAreaIntersectionObserver: null | IntersectionObserver = null;\n\nfunction callUpdateHeightWhenTargetIsVisible(target: HTMLTextAreaElement) {\n  if (textAreaIntersectionObserver === null) {\n    // Create a single observer to watch for the textarea becoming visible\n    textAreaIntersectionObserver = new IntersectionObserver(\n      (entries, observer) => {\n        entries.forEach((entry) => {\n          // Quit if the entry is not visible\n          if (!entry.isIntersecting) {\n            return;\n          }\n          // If the entry is visible (even if it's just a single pixel)\n          // Stop observing the target\n          textAreaIntersectionObserver!.unobserve(entry.target);\n\n          // Update the height of the textarea\n          update_height(entry.target as HTMLTextAreaElement);\n        });\n      }\n    );\n  }\n\n  textAreaIntersectionObserver.observe(target);\n}\n\nfunction update_height(target: HTMLTextAreaElement) {\n  if (target.scrollHeight > 0) {\n    // Automatically resize the textarea to fit its content.\n    target.style.height = \"auto\";\n    target.style.height = target.scrollHeight + \"px\";\n  } else {\n    // The textarea is not visible on the page, therefore it has a 0 scroll height.\n\n    // If we should autoresize the text area height, then we can wait for the textarea to\n    // become visible and call `update_height` again. Hopefully the scroll height is no\n    // longer 0\n    callUpdateHeightWhenTargetIsVisible(target);\n  }\n}\n\n// Update on change\nonDelegatedEvent(\n  \"input\",\n  \"textarea.textarea-autoresize\",\n  (target: HTMLTextAreaElement) => {\n    update_height(target);\n  }\n);\n\n// Update on load\nfunction update_on_load() {\n  if (document.readyState === \"loading\") {\n    // Document still loading, wait 10ms to check again.\n    setTimeout(update_on_load, 10);\n    return;\n  }\n\n  // document.readyState in [\"interactive\", \"complete\"];\\\n  const textAreas = document.querySelectorAll(\n    \"textarea.textarea-autoresize\"\n  ) as NodeListOf<HTMLTextAreaElement>;\n  textAreas.forEach(update_height);\n}\nupdate_on_load();\n"],
  "mappings": ";mBAOA,SAASA,EACPC,EACAC,EACAC,EACA,CACA,SAAS,iBAAiBF,EAAYG,GAAM,CAC1C,IAAMC,EAAKD,EACPC,EAAG,OAAO,QAAQH,CAAQ,GAC5BC,EAASE,EAAG,MAAM,CAEtB,CAAC,CACH,CAGA,IAAIC,EAA4D,KAEhE,SAASC,EAAoCC,EAA6B,CACpEF,IAAiC,OAEnCA,EAA+B,IAAI,qBACjC,CAACG,EAASC,IAAa,CACrBD,EAAQ,QAASE,GAAU,CAErB,CAACA,EAAM,iBAKXL,EAA8B,UAAUK,EAAM,MAAM,EAGpDC,EAAcD,EAAM,MAA6B,EACnD,CAAC,CACH,CACF,GAGFL,EAA6B,QAAQE,CAAM,CAC7C,CAEA,SAASI,EAAcJ,EAA6B,CAC9CA,EAAO,aAAe,GAExBA,EAAO,MAAM,OAAS,OACtBA,EAAO,MAAM,OAASA,EAAO,aAAe,MAO5CD,EAAoCC,CAAM,CAE9C,CAGAR,EACE,QACA,+BACCQ,GAAgC,CAC/BI,EAAcJ,CAAM,CACtB,CACF,EAGA,SAASK,GAAiB,CACxB,GAAI,SAAS,aAAe,UAAW,CAErC,WAAWA,EAAgB,EAAE,EAC7B,MACF,CAGkB,SAAS,iBACzB,8BACF,EACU,QAAQD,CAAa,CACjC,CACAC,EAAe",
  "names": ["onDelegatedEvent", "eventName", "selector", "callback", "e", "e2", "textAreaIntersectionObserver", "callUpdateHeightWhenTargetIsVisible", "target", "entries", "observer", "entry", "update_height", "update_on_load"]
}
