{
  "version": 3,
  "sources": ["../../../srcts/extras/shiny-autoreload.ts"],
  "sourcesContent": ["/* eslint-disable unicorn/filename-case */\n\ndocument.documentElement.classList.add(\"autoreload-enabled\");\n\nconst protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n// Add trailing slash to path, if necessary, before appending \"autoreload\"\nconst defaultPath =\n  window.location.pathname.replace(/\\/?$/, \"/\") + \"autoreload/\";\nconst defaultUrl = `${protocol}//${window.location.host}${defaultPath}`;\n\n// By default, use the defaultUrl. But if there's a data-ws-url attribute on our\n// <script> tag, use that instead.\nconst wsUrl = document.currentScript?.dataset?.wsUrl || defaultUrl;\n\n/**\n * Connects to an autoreload URL and waits for the server to tell us what to do.\n *\n * @param url The ws:// or wss:// URL to connect to.\n * @returns true if the server requests a reload, or false if the connection was\n * successfully established but then closed without the server requesting a\n * reload\n * @throws A nondescript error if the connection fails to be established.\n */\nasync function autoreload(url: string): Promise<boolean> {\n  const ws = new WebSocket(url);\n\n  let success = false;\n\n  return new Promise((resolve, reject) => {\n    ws.onopen = () => {\n      success = true;\n    };\n\n    ws.onerror = (err) => {\n      reject(err);\n    };\n\n    ws.onclose = () => {\n      if (!success) {\n        reject(new Error(\"WebSocket connection failed\"));\n      } else {\n        resolve(false);\n      }\n    };\n\n    ws.onmessage = function (event) {\n      if (event.data === \"autoreload\") {\n        resolve(true);\n      }\n    };\n  });\n}\n\nasync function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function initialize() {\n  while (true) {\n    try {\n      if (await autoreload(wsUrl)) {\n        window.location.reload();\n        return;\n      }\n    } catch (err) {\n      // It's possible for the autoreload() call to throw. If it does, that\n      // means we tried but failed to connect to the autoreload socket. This\n      // probably means that the entire `shiny run --reload` process was\n      // restarted. As of today, the autoreload websocket port number is\n      // randomly chosen for each `shiny run --reload` process, so it's\n      // impossible for us to recover.\n      console.debug(\"Giving up on autoreload\");\n      return;\n    }\n    // If we get here, the connection to the autoreload server was\n    // successful but then got broken. Wait for a second, and then\n    // try to re-establish the connection.\n    await sleep(1000);\n  }\n}\n\ninitialize().catch((err) => {\n  console.error(err);\n});\n\nexport {};\n"],
  "mappings": ";mBAEA,SAAS,gBAAgB,UAAU,IAAI,oBAAoB,EAE3D,IAAMA,EAAW,OAAO,SAAS,WAAa,SAAW,OAAS,MAE5DC,EACJ,OAAO,SAAS,SAAS,QAAQ,OAAQ,GAAG,EAAI,cAC5CC,EAAa,GAAGF,CAAQ,KAAK,OAAO,SAAS,IAAI,GAAGC,CAAW,GAI/DE,EAAQ,SAAS,eAAe,SAAS,OAASD,EAWxD,eAAeE,EAAWC,EAA+B,CACvD,IAAMC,EAAK,IAAI,UAAUD,CAAG,EAExBE,EAAU,GAEd,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtCH,EAAG,OAAS,IAAM,CAChBC,EAAU,EACZ,EAEAD,EAAG,QAAWI,GAAQ,CACpBD,EAAOC,CAAG,CACZ,EAEAJ,EAAG,QAAU,IAAM,CACZC,EAGHC,EAAQ,EAAK,EAFbC,EAAO,IAAI,MAAM,6BAA6B,CAAC,CAInD,EAEAH,EAAG,UAAY,SAAUK,EAAO,CAC1BA,EAAM,OAAS,cACjBH,EAAQ,EAAI,CAEhB,CACF,CAAC,CACH,CAEA,eAAeI,EAAMC,EAAY,CAC/B,OAAO,IAAI,QAASL,GAAY,WAAWA,EAASK,CAAE,CAAC,CACzD,CAEA,eAAeC,GAAa,CAC1B,OAAa,CACX,GAAI,CACF,GAAI,MAAMV,EAAWD,CAAK,EAAG,CAC3B,OAAO,SAAS,OAAO,EACvB,MACF,CACF,MAAc,CAOZ,QAAQ,MAAM,yBAAyB,EACvC,MACF,CAIA,MAAMS,EAAM,GAAI,CAClB,CACF,CAEAE,EAAW,EAAE,MAAOJ,GAAQ,CAC1B,QAAQ,MAAMA,CAAG,CACnB,CAAC",
  "names": ["protocol", "defaultPath", "defaultUrl", "wsUrl", "autoreload", "url", "ws", "success", "resolve", "reject", "err", "event", "sleep", "ms", "initialize"]
}
