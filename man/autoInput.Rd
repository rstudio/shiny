% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/input-auto.R
\name{autoInput}
\alias{autoInput}
\title{Automatic Input Widget}
\usage{
autoInput(x, inputId = NA, label = inputId, selected_fraction = 0.5,
  range = TRUE, inline = TRUE, ...)
}
\arguments{
\item{x}{Input data, which can be a vector, a one-column \code{data.frame}, or a one-element \code{list}. NB: to extract a one-column data.frame or a single element list from a larger one, provide a \emph{single} index to \code{`[`}, i.e. use \code{df[1]} instead of \code{df[,1]} and \code{l[1]} instead of \code{l[[1]]}, the later forms extract the corresponding vector/content; see the examples.}

\item{inputId}{The \code{input} slot that will be used to access the value. With the default value of \code{NA}, if \code{x} has a \code{names} attribute of length one (i.e. in the case of a one-column \code{data.frame}, or a one-element \code{list}), it will be used as \code{inputId}. Specifying an \code{inputId} overrides this behaviour.}

\item{label}{Display label for the control, by default set to the value of \code{inputId}. Set this explicitly to \code{NULL} for no label.}

\item{selected_fraction}{Fraction of the data (between 0 and 1) to select upon creation of the widget.}

\item{range}{Whether to create a widget that allows selecting a range rather than a single value.}

\item{inline}{If TRUE, render the choices inline (i.e. horizontally) in \code{\link{checkboxGroupInput}}.}

\item{...}{passed to the input widget creation functions.}
}
\description{
Constructs an input based on the type and values of provided data.
}
\details{
Widgets are chosen according to the class of \code{x}:
\itemize{
  \item \strong{boolean}: \code{\link{checkboxInput}};

  \item \strong{character}, \strong{factor}: \code{\link{checkboxGroupInput}} if there are 20 or fewer unique values, \code{\link{selectInput}} with \code{multiple=TRUE} otherwise;

  \item \strong{Date}: \code{\link{dateInput}} if \code{range=FALSE}, \code{\link{dateRangeInput}} if \code{range=TRUE};

  \item \strong{numeric}, \strong{POSIXct} (date and time): \code{\link{sliderInput}} with a single value if \code{range=FALSE} or two if \code{range=TRUE}.
}
In this last case, a simple heuristic is used to create good looking bounds for the slider, although the range selected by default is based on the actual data range. For example, if \code{x} varies between 2.16 and 3.98 and \code{selected_fraction=1}, the slider goes from 2 to 4 but the range initially selected would be [2.16, 3.98].
}
\examples{
## Only run examples in interactive R sessions
if (interactive()) {
# simple example
set.seed(1)
autoInput(runif(10), "foo", "My automatic slider")

# create a data.frame with various types of data
n <- 40
d <- data.frame(
  boolean=rep(c(TRUE, FALSE), times=n/2),
  few_levels=letters[1:5],
  many_levels=rep(letters,2)[1:n],
  int=1:n,
  num=runif(n, 0, 5),
  large_num=runif(n, 0, 10^6),
  small_num=runif(n, 0, 0.001),
  date=Sys.Date()+1:n,
  date_time=Sys.time()+1:n
)
str(d)

ui <- fluidPage(
  fluidRow(
    column(
      6,
      h2("Gallery"),
      autoInput(d["boolean"]),
      autoInput(d["few_levels"]),
      autoInput(d["many_levels"]),
      autoInput(d["int"]),
      autoInput(d["num"]),
      autoInput(d["large_num"]),
      autoInput(d["small_num"]),
      autoInput(d["date"]),
      autoInput(d["date"], range=FALSE),
      autoInput(d["date_time"]),
      autoInput(d["date_time"], range=FALSE)
    ),
    column(
      6,
      h2("Options"),
      p("width=100\%:"), autoInput(d["int"], width="100\%", inline=TRUE),
      p("selected_fraction=1:"), autoInput(d["int"], selected_fraction=1),
      p("selected_fraction=0:"), autoInput(d["int"], selected_fraction=0),
      p("selected_fraction=0.0001; when the variable is categorical,
      the number of elements is  rounded up to select at least one:"),
      autoInput(d["few_levels"], selected_fraction=0.0001),
      p("to select nothing, set selected_fraction to exactly 0:"),
      autoInput(d["few_levels"], selected_fraction=0),
      p("inline=FALSE:"), autoInput(d["few_levels"], inline=FALSE),
      p("Change label and ticks aspect:"),
      autoInput(d["small_num"], label=NULL),
      autoInput(d["small_num"], sep=""),
      autoInput(d["small_num"], ticks=FALSE),
      p("etc.")
    )
  )
)
server <- function(input, output) {}
shinyApp(ui, server)
}
}
