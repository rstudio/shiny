% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-lang.R
\name{quoToFunction}
\alias{quoToFunction}
\title{Convert a quosure to a function for a Shiny render function}
\usage{
quoToFunction(q, label = sys.call(-1)[[1]], ..stacktraceon = FALSE)
}
\arguments{
\item{q}{Quosure of the expression \code{x}. When capturing expressions to create
your quosure, it is recommended to use \code{\link[=enquo0]{enquo0()}} to not unquote the
object too early. See \code{\link[=enquo0]{enquo0()}} for more details.}

\item{label}{A label for the object to be shown in the debugger. Defaults to
the name of the calling function.}

\item{..stacktraceon}{Advanced use only. For stack manipulation purposes; see
\code{\link[=stacktrace]{stacktrace()}}.}
}
\description{
This takes a quosure and label, and wraps them into a function that should be
passed to \code{\link[=createRenderFunction]{createRenderFunction()}}.
}
\details{
This function was added in Shiny 1.6.0. Previously, it was recommended to use
\code{\link[=installExprFunction]{installExprFunction()}} or \code{\link[=exprToFunction]{exprToFunction()}} in render functions, but now we
recommend using \code{\link[=quoToFunction]{quoToFunction()}} paired with \code{\link[rlang:enquo0]{rlang::enquo0()}}. This is because \code{quoToFunction()}
does not require package authors to manually handle the \code{env} and \code{quoted} arguments -- that information is captured
by quosures provided by \pkg{rlang}. To support legacy \code{env} and \code{quoted} variables,
please see \code{\link[=installExprFunction]{installExprFunction()}} for more details.
}
\examples{
# Create a new renderer, similar to `renderText()`.
# This is something that toolkit authors will do.
renderTriple <- function(x) {
  # Create render function given the user-supplied quosure or expression.
  func <- quoToFunction(rlang::enquo0(x))

  # Wrap up func, with another function which takes the value of func()
  # and modifies it to concatinate the value three times
  createRenderFunction(
    func,
    transform = function(value, ...) {
      paste(rep(value, 3), collapse=", ")
    },
    outputFunc = textOutput
  )
}


# Example of using the renderer.
# This is something that app authors will do.
values <- reactiveValues(A="text", B="text")

\dontrun{
# Create an output object
output$tripleA <- renderTriple({
  values$A
})
# Create an output object
output$tripleB <- renderTriple({
  values$B
})
}

# At the R console, you can experiment with the renderer using `isolate()`
tripleA <- renderTriple({
  values$A
})

isolate(tripleA())
# "text, text, text"


# If you want to use a quoted expression, use `rlang::inject()`.
q <- quote({ values$A })
tripleA <- rlang::inject(renderTriple(!!q))
# Look at the value
isolate(tripleA())


# Capturing an expression and an environment, using a quosure and `rlang::inject()`:
e <- new.env()
e$vals <- reactiveValues(A = "hello")
# Create a quosure that captures both the expression and environment.
myquo <- rlang::new_quosure(quote({ vals$A }), env = e)
myquo
# `inject()` the quosure into the render function
tripleA <- rlang::inject(renderTriple(!!myquo))
# Look at the value
isolate(tripleA())
# "hello, hello, hello"
}
\seealso{
\itemize{
\item \code{\link[=createRenderFunction]{createRenderFunction()}} for example usage.
\item \code{\link[rlang:enquo0]{rlang::enquo0()}} for more
information about not immediately unquoting when making \code{q}.
}
}
