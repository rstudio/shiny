% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reactives.R
\name{conditionalReactive}
\alias{conditionalReactive}
\title{Reactive expression that only fires when changed}
\usage{
conditionalReactive(
  x,
  checkFunc = NULL,
  fire.on.NULL = c("never", "change", "always"),
  fire.on.NA = c("never", "change", "always"),
  label = NULL
)
}
\arguments{
\item{x}{A reactive.}

\item{checkFunc}{A function that checks for equality. Receives 2 arguments, the new and then the old value. Must return \code{TRUE} for the conditional to fire.}

\item{fire.on.NULL, fire.on.NA}{When new reactive's value is \code{NULL} or \code{NA}, should an update be triggered?
When \code{'change'}, the new and old values are passed to \code{checkFun} to determine the outcome.}

\item{label}{A label for the reactive expression, useful for debugging.}
}
\description{
Prevents triggering an update when an upstream reactive is invalidated, but produces the same value.
}
\details{
Normal use of \code{\link[shiny]{reactive}} will fire every time its upstream
reactives are invalidated - even if the resulting value is the same.
This function allows the use of a method to determine whether the current reactive
should be invalidated (\code{checkFun})

This function enables the  puts in some checks to prevent repeated firing
and some options when the reactive's value is \code{NULL} or code{NA}.

\code{NULL}s can also be aptly handled by \code{\link{req}(!is.null(x()))},
where \code{x} is your reactive.
}
\section{Strategies for handling \code{NULL}s and \code{NA}s}{


When \code{fire.on.NULL} or \code{fire.on.NA} is \code{"never"},
if the reactive's new value is \code{NULL} or \code{NA} (respectively), an update is \emph{never} triggered,
regardless of the reactive's previous value.

When \code{fire.on.NULL} or \code{fire.on.NA} is \code{"always"},
if the reactive's new value is \code{NULL} or \code{NA} (respectively), an update is \emph{always} triggered,
regardless of the reactive's previous value.

See following table how changes are handled for \code{NULL} and \code{fire.on.NULL}. Here, \code{value} may be \code{NA}.
\tabular{lccc}{
Change: \tab "never" \tab "always" \tab "change" \cr
\code{NULL --> NULL} \tab no \tab yes \tab passed on to \code{checkFun} \cr
\code{NULL --> value} \tab yes \tab yes \tab passed on to \code{checkFun} \cr
\code{value --> NULL} \tab no \tab yes \tab passed on to \code{checkFun} \cr
}

See following table how changes are handled for \code{NA}s and \code{fire.on.NA}.
\tabular{lccc}{
Change: \tab "never" \tab "always" \tab "change" \cr
\code{NULL --> value} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \cr
\code{NULL --> all(is.na)} \tab no \tab yes \tab passed on to \code{checkFun} \cr
\code{all(is.na) --> value} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \cr
\code{all(is.na) --> all(is.na)}  \tab no \tab yes \tab passed on to \code{checkFun} \cr
\code{value --> value} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \tab passed on to \code{checkFun} \cr
\code{value --> all(is.na)}  \tab no \tab yes \tab passed on to \code{checkFun} \cr
}
}

\examples{
\dontrun{
  # wrap inputs in reactive
  x <- conditionalReactive(reactive(input$x))

  values <- reactiveValues(A=1)

  reactiveB <- reactive({
     values$A + (runif(1) > 0.5)
  })

  # do not re-calculate when reactiveB is updated to same value
  output$res <- renderText({
    val <- conditionalReactive(reactiveB())()

    Sys.sleep(3) ## some time consuming calculations
    val
  })
  # see bindCache for simple manners to re-use results from reactive expressions.
}
}
\seealso{
\code{\link{req}}, \code{\link{validate}} for ensuring proper values in place before continuing.
\code{\link{bindCache}} to re-use results from previous calculations.
}
