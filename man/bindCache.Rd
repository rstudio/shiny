% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bind-cache.R
\name{bindCache}
\alias{bindCache}
\title{Add caching with reactivity to an object}
\usage{
bindCache(x, ..., cache = "app")
}
\arguments{
\item{x}{The object to add caching to.}

\item{...}{One or more expressions to use in the caching key.}

\item{cache}{The scope of the cache, or a cache object. This can be \code{"app"}
(the default), \code{"session"}, or a cache object like a \code{\link[cachem:cache_disk]{cachem::cache_disk()}}.
See the Cache Scoping section for more information.}
}
\description{
\code{bindCache()} adds persistent caching to the following kinds of objects used
in Shiny:
\itemize{
\item \code{\link[=reactive]{reactive()}} expressions.
\item \verb{render*} functions, like \code{\link[=renderText]{renderText()}},
\code{\link[=renderTable]{renderTable()}}, and so on.
}

Ordinary \code{\link[=reactive]{reactive()}} expressions automatically cache and reuse their \emph{most
recent} value, which helps to avoid redundant computation in downstream
reactive expressions). However, they have no ability to cache a \emph{history} of
values (i.e., they leverage a \emph{transient} cache, but have no inherent ability
to leverage a \emph{persistent} cache). \code{bindCache()} adds a persistent cache to
reactive objects, so that computations may be shared across (or within) user
sessions. As a result, \code{bindCache()} can dramatically improve performance,
but it does take additional effort to be implemented properly.

\code{bindCache()} requires a \emph{cache key} -- this key is used to determine if a
computation has occurred before and hence can be retrieved from the cache. If
you're familiar with the concept of memoizing pure functions (e.g., the
\pkg{memoise} package), you can think of the cache key as the input(s) to a
pure function. As such, one should take care to make sure the use of
\code{bindCache()} is \emph{pure} in the same sense, namely:
\enumerate{
\item The return value (e.g., \code{3}) is the same for the same key (e.g., \code{input$x = 1} & \code{input$y = 2})
\item Evaluation has no side-effects.
}\if{html}{\out{<div class="NA">}}\preformatted{r <- reactive(\{ input$x + input$y \}) \%>\%
  bindCache(input$x, input$y)
}\if{html}{\out{</div>}}

The largest performance improvements occur when the cache key is fast to
compute and the reactive expression is slow to compute. To compute the cache
key, \code{bindCache()} must \href{https://en.wikipedia.org/wiki/Hash_function}{hash}
the contents of \code{...}, so it's best to avoid including large objects in a
cache key since that can will result in slow hashing. It's also best to avoid
reference objects (e.g., \code{\link[=environment]{environment()}}, \code{\link[R6:R6Class]{R6::R6()}}, etc) since computing
the hash requires serialization (unexpected things can happen when
serializing reference objects).

For \code{reactive()}s that are really slow, it's often natural to pair \code{\link[=bindCache]{bindCache()}}
with \code{\link[=bindEvent]{bindEvent()}} so that no computation is performed until the user
explicitly requests it (for more, see the Details section of \code{\link[=bindEvent]{bindEvent()}}).
}
\section{Cache scope}{


By default, a \code{bindCache()} is scoped to the running application. That
means that it shares a cache with all user sessions connected to the
application (within the R process). This is done with the \code{cache}
parameter's default value, \code{"app"}.

With an app-level cache scope, one user can benefit from the work done for
another user's session. In most cases, this is the best way to get
performance improvements from caching. However, in some cases, this could
leak information between sessions. For example, if the cache key does not
fully encompass the inputs used by the value (i.e., it's not pure), then data could leak between
the sessions. Or if a user sees that a cached reactive returns its value
very quickly, they may be able to infer that someone else has already used
it with the same values.

It is also possible to scope the cache to the session, with
\code{cache="session"}. This removes the risk of information leaking between
sessions, but then one session cannot benefit from computations performed in
another session.

It is possible to pass in caching objects directly to
\code{bindCache()}. This can be useful if, for example, you want to use a
particular type of cache with specific cached reactives, or if you want to
use a \code{\link[cachem:cache_disk]{cachem::cache_disk()}} that is shared across multiple processes and
persists beyond the current R session.

To use different settings for an application-scoped cache, you can call
\code{\link[=shinyOptions]{shinyOptions()}} at the top of your app.R, server.R, or
global.R. For example, this will create a cache with 500 MB of space
instead of the default 200 MB:\preformatted{shinyOptions(cache = cachem::cache_mem(size = 500e6))
}

To use different settings for a session-scoped cache, you can set
\code{self$cache} at the top of your server function. By default, it will create
a 200 MB memory cache for each session, but you can replace it with
something different. To use the session-scoped cache, you must also call
\code{bindCache()} with \code{cache="session"}. This will create a 100 MB cache for
the session:\preformatted{function(input, output, session) \{
  session$cache <- cachem::cache_mem(size = 100e6)
  ...
\}
}

If you want to use a cache that is shared across multiple R processes, you
can use a \code{\link[cachem:cache_disk]{cachem::cache_disk()}}. You can create a application-level shared
cache by putting this at the top of your app.R, server.R, or global.R:\preformatted{shinyOptions(cache = cachem::cache_disk(file.path(dirname(tempdir()), "myapp-cache"))
}

This will create a subdirectory in your system temp directory named
\code{myapp-cache} (replace \code{myapp-cache} with a unique name of
your choosing). On most platforms, this directory will be removed when
your system reboots. This cache will persist across multiple starts and
stops of the R process, as long as you do not reboot.

To have the cache persist even across multiple reboots, you can create the
cache in a location outside of the temp directory. For example, it could
be a subdirectory of the application:\preformatted{shinyOptions(cache = cachem::cache_disk("./myapp-cache"))
}

In this case, resetting the cache will have to be done manually, by deleting
the directory.

You can also scope a cache to just one item, or selected items. To do that,
create a \code{\link[cachem:cache_mem]{cachem::cache_mem()}} or \code{\link[cachem:cache_disk]{cachem::cache_disk()}}, and pass it
as the \code{cache} argument of \code{bindCache()}.
}

\section{Async with cached reactives}{


With a cached reactive expression, the key and/or value expression can be
\emph{asynchronous}. In other words, they can be promises --- not regular R
promises, but rather objects provided by the
\href{https://rstudio.github.io/promises/}{\pkg{promises}}  package, which
are similar to promises in JavaScript. (See \code{\link[promises:promise]{promises::promise()}} for more
information.) You can also use \code{\link[future:future]{future::future()}} objects to run code in a
separate process or even on a remote machine.

If the value returns a promise, then anything that consumes the cached
reactive must expect it to return a promise.

Similarly, if the key is a promise (in other words, if it is asynchronous),
then the entire cached reactive must be asynchronous, since the key must be
computed asynchronously before it knows whether to compute the value or the
value is retrieved from the cache. Anything that consumes the cached
reactive must therefore expect it to return a promise.
}

\section{Computing cache keys}{


When \code{\link[=bindEvent]{bindEvent()}} computes a cache key, it combines key expression(s)
(\code{...}) with the (unevaluated) reactive expression its bound to.
As a result, two different reactives with the same key won't read from the same
cache, unless they have exactly the same code expression (the latter case
is important for sharing cache when \code{cache="app"} where separate
cached reactive objects are created for each user).
}

\section{Developing render functions for caching}{


If you've implemented your own \verb{render*()} function, you may need to
provide information to \code{\link[=createRenderFunction]{createRenderFunction()}} (or
\code{htmlwidgets::shinyRenderWidget()}, if you've authored an
\pkg{htmlwidgets}) in order for \code{bindCache()} to correctly compute a cache
key. In general, it's best practice to provide a \code{label} id, the user's
\code{expr}, as well as any other arguments that may influence the final value
(any the idea here is to produce a pure cache key).\preformatted{myWidget <- function(expr, ...) \{
  hint <- list(label = "myWidget", userExpr = expr, ...)
  htmlwidgets::shinyRenderWidget(expr, myWidgetOutput, cacheHint = hint)
\}
}

In some cases, a pure cache key can be automatically derived, so explicitly
providing the \code{cacheHint} may not be needed. To check if it is needed, call
the internal \code{shiny:::extractCacheHint()} on the \verb{render*()} function to
see what information is included in the cache key. At the very least, this
should include the user's expression \code{{ input$x }}.\preformatted{shiny:::extractCacheHint(myWidget(\{ input$x \}))
}
}

\section{Uncacheable objects}{


Some render functions cannot be cached, typically because they have side
effects or modify some external state, and they must re-execute each time
in order to work properly.

For developers of such code, they should call \code{\link[=createRenderFunction]{createRenderFunction()}} or
\code{\link[=markRenderFunction]{markRenderFunction()}} with \code{cacheHint = FALSE}.
}

\examples{
\dontrun{
rc <- bindCache(
  x = reactive({
    Sys.sleep(2)   # Pretend this is expensive
    input$x * 100
  }),
  input$x
)

# Can make it prettier with the \%>\% operator
library(magrittr)

rc <- reactive({
  Sys.sleep(2)
  input$x * 100
}) \%>\%
  bindCache(input$x)

}

## Only run app examples in interactive R sessions
if (interactive()) {

# Basic example
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      # The value expression is an _expensive_ computation
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)

    output$txt <- renderText(r())
  }
)


# Caching renderText
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    output$txt <- renderText({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)
  }
)


# Demo of using events and caching with an actionButton
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    actionButton("go", "Go"),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y) \%>\%
      bindEvent(input$go)
      # The cached, eventified reactive takes a reactive dependency on
      # input$go, but doesn't use it for the cache key. It uses input$x and
      # input$y for the cache key, but doesn't take a reactive depdency on
      # them, because the reactive dependency is superseded by addEvent().

    output$txt <- renderText(r())
  }
)

}

}
\seealso{
\code{\link[=bindEvent]{bindEvent()}}, \code{\link[=renderCachedPlot]{renderCachedPlot()}} for caching plots.
}
