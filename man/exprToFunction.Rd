% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-lang.R
\name{exprToFunction}
\alias{exprToFunction}
\alias{installExprFunction}
\title{Convert an expression to a function}
\usage{
exprToFunction(expr, env = parent.frame(), quoted = FALSE)

installExprFunction(
  expr,
  name,
  eval.env = parent.frame(2),
  quoted = FALSE,
  assign.env = parent.frame(1),
  label = deparse(sys.call(-1)[[1]]),
  wrappedWithLabel = TRUE,
  ..stacktraceon = FALSE
)
}
\arguments{
\item{expr}{A quoted or unquoted expression, or a quosure.}

\item{env}{The desired environment for the function. Defaults to the
calling environment two steps back.}

\item{quoted}{Is the expression quoted?}

\item{name}{The name the function should be given}

\item{eval.env}{The desired environment for the function. Defaults to the
calling environment two steps back.}

\item{assign.env}{The environment in which the function should be assigned.}

\item{label}{A label for the object to be shown in the debugger. Defaults to
the name of the calling function.}

\item{wrappedWithLabel, ..stacktraceon}{Advanced use only. For stack manipulation purposes; see
\code{\link[=stacktrace]{stacktrace()}}.}
}
\description{
This is to be called from another function, because it will attempt to get
an unquoted expression from two calls back. Note: as of Shiny 1.7.0, it is
recommended to use \code{\link[=getQuosure]{getQuosure()}} and \code{\link[=quoToFunction]{quoToFunction()}} instead of
\code{exprToFunction()} and \code{installExprFunction()}. See the examples for
information on how to migrate to \code{getQuosure()} and \code{quoToFunction()}.
}
\details{
For \code{exprToFunction()}:
If \code{expr} is a quoted expression, then this just converts it to a function.
If \code{expr} is a function, then this simply returns expr (and prints a
deprecation message).
If \code{expr} was a non-quoted expression from two calls back, then this will
quote the original expression and convert it to a function.

\code{installExprFunction} installs an expression in the given environment as a
function, and registers debug hooks so that breakpoints may be set in the
function.

\code{installExprFunction} can replace \code{exprToFunction} as follows: we may use
\code{func <- exprToFunction(expr)} if we do not want the debug hooks, or
\code{installExprFunction(expr, "func")} if we do. Both approaches create a
function named \code{func} in the current environment.
}
\examples{
# These examples demonstrate the old method, with exprToFunction() and
# installExprFunction(), as well as how to replace them, with getQuosure().

# Version 1: exprToFunction()
# The old way of converting the expression to a quosure, with exprToFunction()
renderTriple <- function(expr, env=parent.frame(), quoted=FALSE) {
  # Convert expr to a function
  func <- shiny::exprToFunction(expr, env, quoted)

  function() {
    value <- func()
    paste(rep(value, 3), collapse=", ")
  }
}

# Version 2: installExprFunction()
# The not-quite-as-old way of converting the expression to a quosure, with
# installExprFunction()
renderTriple <- function(expr, env=parent.frame(), quoted=FALSE) {
  # Convert expr to a function
  installExprFunction(expr, "func", env, quoted)

  function() {
    value <- func()
    paste(rep(value, 3), collapse=", ")
  }
}

# Version 3: Replacing the old functions with getQuosure() and quoToFunction()
# This keeps the `env` and `quoted` arguments, in case they are needed for
# backward compatibility
renderTriple <- function(expr, env=parent.frame(), quoted=FALSE) {
  # Convert expr to a quosure, and then to a function
  q <- getQuosure(expr, env, quoted)
  func <- quoToFunction(q)

  function() {
    value <- func()
    paste(rep(value, 3), collapse=", ")
  }
}


# Version 4: getQuosure()
# This is the recommended way to use getQuosure() and quoToFunction(), and
# it discards `env` and `quoted`, for simplicity.
renderTriple <- function(expr) {
  # Convert expr to a quosure, and then to a function
  q <- getQuosure(expr)
  func <- quoToFunction(q)

  function() {
    value <- func()
    paste(rep(value, 3), collapse=", ")
  }
}

# Example of using the renderer.
# This is something that app authors will do.
values <- reactiveValues(A="text")

\dontrun{
# Create an output object
output$tripleA <- renderTriple({
  values$A
})
}

# At the R console, you can experiment with the renderer using isolate()
tripleA <- renderTriple({
  values$A
})

isolate(tripleA())
# "text, text, text"
}
