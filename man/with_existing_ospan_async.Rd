% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/otel.R
\name{with_existing_ospan_async}
\alias{with_existing_ospan_async}
\title{Execute code within an existing OpenTelemetry span for asynchronous operations}
\usage{
with_existing_ospan_async(name, expr, ..., domain = getDefaultReactiveDomain())
}
\arguments{
\item{name}{Character string. The name of the existing span to retrieve from
the reactive domain.}

\item{expr}{An expression to evaluate within the span context.}

\item{...}{Currently unused.}

\item{domain}{The reactive domain to retrieve the span from. Defaults to
the current reactive domain from \code{getDefaultReactiveDomain()}.}
}
\value{
The result of evaluating \code{expr} within the active span context.
}
\description{
Executes the given expression within the context of an existing OpenTelemetry
span that was previously stored in the reactive domain. This function retrieves
the span by name and sets up the appropriate promise domain for handling
asynchronous operations. Unlike \code{with_ospan_async}, this function does not
create a new span but uses an existing one.
}
\details{
This function is particularly useful for operations that need to run within
the context of a span that was created elsewhere and stored in the reactive
domain, such as reactive lock operations or observer runs. It properly sets
up the promise domain to ensure that asynchronous operations are correctly
traced.
}
\examples{
\dontrun{
# First, create and store a span in the domain
span <- start_ospan("parent_operation")

# Later, use the existing span by name
result <- with_existing_ospan_async("parent_operation", {
  # ... do work within the existing span ...
  some_function()
})

# End the span when done
end_ospan(span)
}

}
\seealso{
\code{\link{with_ospan_async}} for creating and using new spans,
\code{\link{start_ospan}} for manual span creation
}
\keyword{internal}
